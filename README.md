# Design-pattern

适配器模式(adapter)+享元模式(flyweight)

# Adapter(适配器模式)

## 1.1 实现描述

适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。将一个类的接口转换成客户希望的另外一个接口，这就是适配器需要做的事情，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。通常有两种方式实现适配器模式，一种是类适配器，类适配器目前已不太使用，另一种实现方式是对象适配器，通常情况下采用对象适配器会使得代码更易扩展与维护。

适配器模式在花店场景中处理不同供应商提供的花卉信息。通过适配器，花店可以统一不同供应商的接口，使其能够轻松地展示花卉信息。

## 1.2 UML图

`FlowerInfo`作为目标接口，两个花卉供应商分别通过适配器`FlowerSupplierAdapter1`和`FlowerSupplierAdapter2`适配到目标接口上。适配器内部包含了对应的成员变量用于动态设置花卉信息。

其类图如下所示

![](https://xiypbocsp9v.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGQ3NTBlNWJkMTQyZWFiNjBkZGY0MzJmMzY1MWVkZjRfZmRWcnhtMlRNejVsdlJETnJxQzBPNEdPTHJ5cHMyazlfVG9rZW46RUd4V2JMcGtYbzZEZHp4WVVpbmNzcWVLbjJiXzE3MDMzMDk4NDU6MTcwMzMxMzQ0NV9WNA)

## 1.3 代价分析

优势：

- 提高了系统的灵活性，使得花店能够方便地与不同的花卉供应商合作。

- 通过统一的接口，降低了系统对具体供应商实现的依赖性，使得系统更易于扩展和维护。

缺点：

- 引入了适配器类，增加了系统的复杂性和代码量。

- 可能存在性能损失，特别是在适配器中需要进行额外的转换和处理时。

代价：

1. 增加复杂性：
   
   1.   引入适配器模式会增加系统的复杂性。每个供应商可能需要一个专门的适配器，而每个适配器都需要了解原始类和目标接口的细节。

2. 维护成本增加：
   
   1.   随着系统的变化，特别是当花卉供应商的接口发生变化时，适配器模式可能需要进行调整。这可能导致维护成本的增加。

3. 可能引入性能损失：
   
   1.   适配器模式可能引入一些性能损失，因为在适配器中进行了额外的转换和处理。这可能影响系统的性能。

4. 不灵活：
   
   1.   如果原始类的接口发生变化，适配器也需要相应地进行调整。这可能导致系统的部分代码需要修改，降低了系统的灵活性。

## 1.4 其他内容

# Flyweight(享元模式)

## 2.1 实现描述

享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。

在花店场景中，享元模式可以被运用于优化对于花卉对象的创建和管理，特别是在存在大量相似花卉对象的情况下。如果花店经常处理大量相似的花卉对象，比如相同种类或相同颜色的花朵，那么使用享元模式可以显著减少内存占用。

## 2.2 UML图

在这个设计中，`ConcreteFlower`类代表了具体的花卉类型，而`FlowerFactory`类作为享元工厂，负责创建和管理花卉对象。通过外部状态的传递，系统能够在创建对象时动态设置花卉的颜色、产地和花语，实现了对相似对象的共享和复用。

其类图如下所示

![](https://xiypbocsp9v.feishu.cn/space/api/box/stream/download/asynccode/?code=MzkwOGIxMDQyMGFjNWYzM2Q1ZTJjOTk2N2MzNGEzZGVfSkV1MGplRWtWVTJmV1htM0VGaDVhT0ZmZ0dPUjVxaDFfVG9rZW46S05kYmJmVDZpb1V4VTR4M1p4UWNvbzVvbjVmXzE3MDMzMDk4NDU6MTcwMzMxMzQ0NV9WNA)

## 2.3 代价分析

代价：

1. 复杂性增加：
   
   1.   引入享元模式会增加系统的复杂性，需要引入额外的接口和类来实现内部状态和外部状态的分离。这可能会导致系统变得难以理解和维护。

2. 外部状态管理：
   
   1.   需要管理外部状态的传递和维护，确保在创建对象时正确设置外部状态参数。这可能需要引入更多的参数和方法，使得代码变得繁琐。

3. 同步问题：
   
   1.   如果不正确地管理外部状态的传递，可能导致在不同地方对相同对象的外部状态进行不同的设置，从而引发同步问题。这可能需要引入额外的控制机制来避免同步问题。

4. 不适用于所有情景：
   
   1.   享元模式适用于存在大量相似对象的情景，如果对象之间的差异较大，使用享元模式可能会失去优势，甚至带来额外的开销。

5. 内部状态的不变性：
   
   1.   享元模式中的内部状态通常被设计为不可变，即一旦创建就不能更改。如果需要频繁地修改内部状态，可能需要重新考虑是否适用享元模式。

6. 资源释放：
   
   1.   管理外部状态可能需要手动释放资源，尤其是在涉及到动态分配内存的情况下，容易引起资源泄漏的问题。

## 2.4 其他内容
